# -*- coding: utf-8 -*-
"""actividad 2 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IgPz9Ex8k9M945VBOmwQVpmj6UrlO4Tl

generador numeros aleatorios
"""

import random

n=3

aleatorios = [random.randint(1,100) for i in range(n)]
print(aleatorios)


array = []
size = [100]

for i in size:
  array = [random.randint(0,100) for _ in range(i)]
  print(array)

"""**1 burbuja**"""

import time
import random
import matplotlib.pyplot as plt
import numpy as np

#metodo de ordenamiento burbuja
def burbuja(lista):
  for i in range (0,len(lista)-1):
    for j in range (0,len(lista)-i-1):
      if(lista[j]>lista[j+1]):
        lista[j],lista[j+1]=lista[j+1],lista[j]

  return lista

#tamaño de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_burbuja = []



#generar lista aleatoria
for i1 in size:
  array = [random.randint(0,100) for _ in range(i1)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time1 = time.perf_counter()
  Lista_ordenada_burbuja = burbuja(array)
  end_time1 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time1}")
  print(f"tiempo final: {end_time1}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_burbuja}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time1 - start_time1
  execution_times_burbuja.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tamaño {i1}: {tiempo_transcurrido} segundos")
  print("\n")


#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecución       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_burbuja):
    print(f"Tamaño: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gráfica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_burbuja, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tamaño de la lista')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Burbuja')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()



# Guardar los últimos tiempos y tamaño
endtime1 = end_time1
lastsize1 = i1

"""**2 burbuja mejorada**"""

import random
import time
import matplotlib.pyplot as plt

#metodo de ordenamiento burbuja mejorado
def burbuja_mejorado(lista):
    i = 0
    control = True

    while (i <= len(lista)-2) and control:
        control = False
        for j in range(0, len(lista)-i-1):
            if(lista[j] > lista[j+1]):
                lista[j], lista[j+1] = lista[j+1], lista[j]
                control = True
        i += 1
    return lista


#tamaño de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_burbuja_mejorado = []

#generar lista aleatoria
for i2 in size:
  array = [random.randint(0,100) for _ in range(i2)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time2 = time.perf_counter()
  Lista_ordenada_burbuja_mejorado = burbuja_mejorado(array)
  end_time2 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time2}")
  print(f"tiempo final: {end_time2}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_burbuja_mejorado}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time2 - start_time2
  execution_times_burbuja_mejorado.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tamaño {i2}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecución       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_burbuja_mejorado):
    print(f"Tamaño: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gráfica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_burbuja_mejorado, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tamaño de la lista')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Burbuja Mejorado')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime2= end_time2
lastsize2 = i2

"""**3 Coctel**"""

import random
import time
import matplotlib.pyplot as plt


#metodo de ordenamiento cóctel o burbuja bidireccional
def coctel(lista):
    izquierda = 0
    derecha = len(lista) - 1
    control = True
    while (izquierda < derecha) and control:
        control = False
        for i in range(izquierda, derecha):
            if(lista[i] > lista[i+1]):
                control = True
                lista[i], lista[i+1] = lista[i+1], lista[i]
        derecha -= 1
        for j in range(derecha, izquierda, -1):
            if(lista[j] < lista[j-1]):
                control = True
                lista[j], lista[j-1] = lista[j-1], lista[j]
        izquierda += 1
    return lista


#tamaño de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000
,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_coctel = []


#generar lista aleatoria
for i3 in size:
  array = [random.randint(0,100) for _ in range(i3)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time3 = time.perf_counter()
  Lista_ordenada_coctel = coctel(array)
  end_time3 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time3}")
  print(f"tiempo final: {end_time3}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_coctel}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time3 - start_time3
  execution_times_coctel.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tamaño {i3}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecución       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_coctel):
    print(f"Tamaño: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gráfica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_coctel, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tamaño de la lista')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Coctel')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime3 = end_time3
lastsize3 = i3

"""**4 Seleccion**"""

import time
import random
import matplotlib.pyplot as plt

#metodo de ordenamiento seleccion
def seleccion(lista):
    """Método de ordenamiento selección."""
    for i in range(0, len(lista)-1):
        minimo = i
        for j in range(i+1, len(lista)):
            if(lista[j] < lista[minimo]):
                minimo = j
        lista[i], lista[minimo] = lista[minimo], lista[i]
    return lista

array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_seleccion = []
#generar lista aleatoria
for i4 in size:
  array = [random.randint(0,100) for _ in range(i4)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time4 = time.perf_counter()
  Lista_ordenada_seleccion = seleccion(array)
  end_time4 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time4}")
  print(f"tiempo final: {end_time4}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_seleccion}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time4 - start_time4
  execution_times_seleccion.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tamaño {i4}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecución       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_seleccion):
    print(f"Tamaño: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gráfica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_seleccion, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tamaño de la lista')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Seleccion')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime4 = end_time4
lastsize4 = i4

"""**5 insercion**"""

import time
import random
import matplotlib.pyplot as plt

#metodo de ordenamiento insercion
def insercion(lista):
    """Método de ordenamiento inserción."""
    for i in range(1, len(lista)+1):
        k = i-1
        while (k > 0) and (lista[k] < lista[k-1]):
            lista[k], lista[k-1] = lista[k-1], lista[k]
            k -= 1
    return lista


array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_insercion = []

#generar lista aleatoria
for i5 in size:
  array = [random.randint(0,100) for _ in range(i5)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time5 = time.perf_counter()
  Lista_ordenada_insercion = insercion(array)
  end_time5 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time5}")
  print(f"tiempo final: {end_time5}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_insercion}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time5 - start_time5
  execution_times_insercion.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tamaño {i5}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecución       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_insercion):
    print(f"Tamaño: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gráfica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_insercion, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tamaño de la lista')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Inserción')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime5 = end_time5
lastsize5 = i5

"""**6 quicksort**"""

import time
import random
import matplotlib.pyplot as plt

#metodo de ordenamiento quicksort
def quicksort(lista):
    """Método de ordenamiento quicksort."""
    if len(lista) <= 1:
        return lista
    else:
        pivot = lista[0]
        left = [x for x in lista[1:] if x < pivot]
        right = [x for x in lista[1:] if x >= pivot]

        return quicksort(left) + [pivot] + quicksort(right)


#tamaño de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_quicksort = []

#generar lista aleatoria
for i6 in size:
  array = [random.randint(0,100) for _ in range(i6)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time6 = time.perf_counter()
  Lista_ordenada_quicksort = quicksort(array)
  end_time6 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time6}")
  print(f"tiempo final: {end_time6}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_quicksort}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time6 - start_time6
  execution_times_quicksort.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tamaño {i6}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecución       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_quicksort):
    print(f"Tamaño: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gráfica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_quicksort, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tamaño de la lista')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Quicksort')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime6 = end_time6
lastsize6 = i6

"""**7 mergesort**"""

import time
import random
import matplotlib.pyplot as plt


def mergesort(lista):

    if len(lista) <= 1:
        return lista
    else:
        medio = len(lista) // 2
        izquierda = []
        for i in range(0, medio):
            izquierda.append(lista[i])
        derecha = []
        for i in range(medio, len(lista)):
            derecha.append(lista[i])
        izquierda = mergesort(izquierda)
        derecha = mergesort(derecha)
        if(izquierda[medio-1] <= derecha[0]):
            izquierda += derecha
            return izquierda
        resultado = merge(izquierda, derecha)
        return resultado

def merge(izquierda,derecha):
    #mezclar las dos listas
    lista_mezclada = []
    while (len(izquierda) > 0 and (len(derecha) > 0)):
        if (izquierda[0] <= derecha[0]):
            lista_mezclada.append(izquierda.pop(0))

        else:
            lista_mezclada.append(derecha.pop(0))
    if len(izquierda) > 0:
            lista_mezclada += izquierda
    if len(derecha) > 0:
            lista_mezclada += derecha
    return lista_mezclada


#tamaño de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_mergesort = []


#generar lista aleatoria
for i7 in size:
  array = [random.randint(0,100) for _ in range(i7)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time7 = time.perf_counter()
  Lista_ordenada_mergesort = mergesort(array)
  end_time7 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time7}")
  print(f"tiempo final: {end_time7}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_mergesort}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time7 - start_time7
  execution_times_mergesort.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tamaño {i7}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecución       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_mergesort):
    print(f"Tamaño: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gráfica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_mergesort, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tamaño de la lista')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Mergesort')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()


endtime7 = end_time7
lastsize7 = i7

"""**8 Count sort**"""

import random
import time
import matplotlib.pyplot as plt


#metodo de ordenamiento countsort
def count_sort(lista, maximo):
    """Método de ordenamiento countsort."""
    lista_conteo = [0] * (maximo + 1)
    lista_ordenada = [None] * len(lista)

    for i in lista:
        lista_conteo[i] += 1

    total = 0
    for i in range(len(lista_conteo)):
        lista_conteo[i], total = total, total + lista_conteo[i]

    for indice in lista:
        lista_ordenada[lista_conteo[indice]] = indice
        lista_conteo[indice] += 1

    return lista_ordenada


#tamaño de la lista
array = []
size = [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500
,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
3100,3200,3300,3400,3500,3600,3700,3800,3900,4000]
execution_times_countsort = []

#generar lista aleatoria
for i8 in size:
  array = [random.randint(0,100) for _ in range(i8)]

  # Crear una copia de la lista original para preservar el estado desordenado
  array_desordenada = array.copy()

  #iniciar tiempo de ejecucion
  start_time8 = time.perf_counter()
  Lista_ordenada_count_sort = count_sort(array, max(array))
  end_time8 = time.perf_counter()

  #fin tiempo de ejecucion
  print(f"tiempo inicial : {start_time8}")
  print(f"tiempo final: {end_time8}")
  #imprimir lista desordenada
  print("lista desordenada:",array_desordenada,"")
  #imprimir lista ordenada
  print(f"lista ordenada: {Lista_ordenada_count_sort}")
  #imprimit los tiempos finales de cada una de las listas
  tiempo_transcurrido = end_time8 - start_time8
  execution_times_countsort.append(tiempo_transcurrido)
  print(f"Tiempo para la lista de tamaño {i8}: {tiempo_transcurrido} segundos")
  print("\n")




#Imprimimos el resumen completos de resultados
print("-------------------------------------------")
print("/    Resumen de Tiempos de Ejecución       /")
print("-------------------------------------------")
for tam, tiempo in zip(size, execution_times_countsort):
    print(f"Tamaño: {tam}  ->  Tiempo: {tiempo} segundos")
print("------------------ -------------------------\n")


# Crear la gráfica
plt.figure(figsize=(12, 8))
plt.plot(size, execution_times_countsort, 'bo-', linewidth=2, markersize=8)
plt.xlabel('Tamaño de la lista')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Rendimiento del Algoritmo de Ordenamiento Count Sort')
plt.grid(True, alpha=0.3)

# Configurar el eje X para mostrar todos los valores
plt.xticks(size, rotation=45)
plt.tight_layout()  # Ajusta el layout para que no se corten las etiquetas
plt.show()

endtime8 = end_time8
lastsize8 = i8




# Usamos las variables ya existentes para comparar la eficiencia de los algoritmos

import matplotlib.pyplot as plt

# Asumimos que tienes variables como:
# execution_times_burbuja, execution_times_burbuja_mejorado, execution_times_coctel, etc.
# Y que cada una es una lista de tiempos para los distintos tamaños de lista.
# Para comparar el más eficiente en el último tamaño (por ejemplo, n=4000):

# Nombres de los algoritmos
algoritmos = [
    'Burbuja',
    'Burbuja Mejorado',
    'Coctel',
    'Selección',
    'Inserción',
    'Quicksort',
    'Mergesort',
    'Count Sort'
]

# Obtenemos el último tiempo de cada algoritmo (para el tamaño más grande)
# Asegúrate de que estas variables existen y están actualizadas en tu código principal
tiempos_ejecucion = [
    execution_times_burbuja[-1],
    execution_times_burbuja_mejorado[-1],
    execution_times_coctel[-1],
    execution_times_seleccion[-1],
    execution_times_insercion[-1],
    execution_times_quicksort[-1],
    execution_times_mergesort[-1],
    execution_times_countsort[-1],# Count Sort, ya que tu variable es 'execution_times'
]

# Crear la figura y los ejes para la gráfica
plt.figure(figsize=(12, 8))

# Crear la gráfica de barras
barras = plt.bar(algoritmos, tiempos_ejecucion, color='skyblue')

# Añadir títulos y etiquetas
plt.xlabel('Algoritmo de Ordenamiento')
plt.ylabel('Tiempo de Ejecución (segundos)')
plt.title(f'Comparación de Eficiencia de Algoritmos (para n={lastsize8})')
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Añadir el valor exacto encima de cada barra
for barra in barras:
    yval = barra.get_height()
    plt.text(barra.get_x() + barra.get_width()/2.0, yval, f'{yval:.4f}', va='bottom', ha='center')

plt.tight_layout()
plt.show()




"""burbuja(lista): El método más intuitivo. Compara cada elemento con el siguiente y los intercambia si están en el orden incorrecto. Repite este proceso una y otra vez, haciendo que los elementos más grandes "floten" como burbujas hacia el final de la lista.

burbuja_mejorado(lista): Una versión más inteligente del anterior. Si en una pasada completa por la lista no hace ningún intercambio, significa que la lista ya está ordenada y el algoritmo se detiene para no trabajar de más.

coctel(lista) (o Cocktail Shaker Sort): Es una variante del burbuja. En lugar de ir siempre en una dirección, va de izquierda a derecha (llevando el más grande al final) y luego de derecha a izquierda (llevando el más pequeño al inicio). Es como sacudir una coctelera. 🍸

seleccion(lista): Este algoritmo busca el elemento más pequeño de toda la lista y lo pone en la primera posición. Luego, busca el segundo más pequeño y lo pone en la segunda posición, y así sucesivamente.

insercion(lista): Funciona como cuando ordenas cartas en tu mano. Tomas una carta (un elemento) y la vas insertando en el lugar correcto dentro de las que ya tienes ordenadas.

quicksort(lista): Un algoritmo muy popular y eficiente. Utiliza la estrategia "divide y vencerás". Elige un elemento como "pivote", y divide la lista en dos: los menores al pivote y los mayores al pivote. Luego, repite el proceso recursivamente con las dos sub-listas hasta que todo está ordenado.

mergesort(lista): Otro algoritmo de "divide y vencerás". Parte la lista por la mitad repetidamente hasta tener muchas listas de un solo elemento. Luego, las va uniendo (fusionando o merge) de dos en dos de manera ordenada hasta tener la lista completa ordenada de nuevo. La función merge es su ayudante para hacer esta fusión.

count_sort(lista, maximo): Este es un algoritmo especial. No compara elementos entre sí. En su lugar, cuenta cuántas veces aparece cada número. Luego, usa esas cuentas para reconstruir la lista ya ordenada. Es extremadamente rápido, pero tiene una desventaja: solo funciona bien con números enteros y cuando conoces el rango de valores (de 0 al maximo).
"""